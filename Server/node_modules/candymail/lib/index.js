"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unsubscribeUser = exports.sendMessagesNow = exports.clearAllScheduledMessages = exports.getScheduledMessagesBeforeTime = exports.getAllScheduledMessages = exports.runWorkflow = exports.destroy = exports.stop = exports.start = exports.init = void 0;
const dotenv = require("dotenv");
dotenv.config();
const cron = require("node-cron");
const moment = require("moment");
const helper_1 = require("./src/utils/helper");
const logger_1 = require("./src/utils/logger");
const queue_1 = require("./src/queue");
Object.defineProperty(exports, "getAllScheduledMessages", { enumerable: true, get: function () { return queue_1.getAllScheduledMessages; } });
Object.defineProperty(exports, "getScheduledMessagesBeforeTime", { enumerable: true, get: function () { return queue_1.getScheduledMessagesBeforeTime; } });
Object.defineProperty(exports, "clearAllScheduledMessages", { enumerable: true, get: function () { return queue_1.clearAllScheduledMessages; } });
const unsubscribe_1 = require("./src/unsubscribe");
Object.defineProperty(exports, "unsubscribeUser", { enumerable: true, get: function () { return unsubscribe_1.unsubscribeUser; } });
const automation_1 = require("./src/automation");
Object.defineProperty(exports, "init", { enumerable: true, get: function () { return automation_1.init; } });
const workflow_1 = require("./src/workflow");
Object.defineProperty(exports, "runWorkflow", { enumerable: true, get: function () { return workflow_1.runWorkflow; } });
const task = cron.schedule('* * * * *', () => __awaiter(void 0, void 0, void 0, function* () {
    yield sendMessagesNow();
}), {
    scheduled: false,
});
const start = () => __awaiter(void 0, void 0, void 0, function* () {
    task.start();
});
exports.start = start;
const stop = () => {
    task.stop();
};
exports.stop = stop;
const destroy = () => {
    task.destroy();
};
exports.destroy = destroy;
const sendMessagesNow = () => __awaiter(void 0, void 0, void 0, function* () {
    const today = moment.utc().toDate();
    const messagesToBeSent = yield queue_1.getScheduledMessagesBeforeTime(today);
    if (messagesToBeSent) {
        for (const message of messagesToBeSent) {
            const { email: { sendTo }, } = message;
            const isUnsubscribed = yield unsubscribe_1.hasUnsubscribed(sendTo);
            if (isUnsubscribed) {
                logger_1.log(`The user ${sendTo} you are trying to send a message to has already unsubscribed`);
            }
            else {
                helper_1.sendEmail(message);
            }
        }
    }
});
exports.sendMessagesNow = sendMessagesNow;
